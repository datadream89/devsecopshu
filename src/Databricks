import java.io.File
import com.typesafe.config.{Config, ConfigFactory}
import scala.collection.JavaConverters._

object ConfigParser {
  def main(args: Array[String]): Unit = {
    val folderPath = "configs/" // Update the folder path as needed

    val configFileNames: List[String] = getListOfConfigFiles(folderPath)

    // Parse each config file and extract sections and their values recursively
    for (configFile <- configFileNames) {
      val config: Config = ConfigFactory.parseFile(new File(configFile))
      processConfig(config, "")
    }
  }

  def processConfig(config: Config, currentPath: String): Unit = {
    val currentSection = if (currentPath.isEmpty) "" else s"$currentPath."

    config.root().keySet().asScala.foreach { section =>
      val fullPath = s"$currentSection$section"
      val value = config.getAnyRef(section)
      value match {
        case obj: com.typesafe.config.ConfigObject =>
          // Handle sections with object values (recursively)
          processConfig(obj.toConfig, fullPath)
        case _ =>
          // Handle other types (skipping)
      }
      processSection(config, fullPath)
    }
  }

  def processSection(config: Config, section: String): Unit = {
    val value1 = config.getString(s"$section.ser")
    val value2 = config.getString(s"$section.frt")
    // Here, you can define your function and process the section and values as needed
    println(s"Processing section: $section with value1: $value1 and value2: $value2")
  }

  def getListOfConfigFiles(folderPath: String): List[String] = {
    val folder = new File(folderPath)
    if (folder.exists() && folder.isDirectory) {
      folder.listFiles().filter(_.isFile).map(_.getAbsolutePath).toList
    } else {
      throw new IllegalArgumentException("Invalid folder path")
    }
  }
}
