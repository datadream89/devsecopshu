import io.snowpark.{Session, DataFrame}
import io.snowpark.functions._

object SnowparkExample {
  def main(args: Array[String]): Unit = {
    // Initialize Snowpark session
    val session: Session = Session.builder()
      .appName("Snowpark Example")
      .master("local[*]") // Change this to your Spark master URL for distributed execution
      .config("snowflakeURL", "your_snowflake_url")
      .config("snowflakeUser", "your_snowflake_user")
      .config("snowflakePassword", "your_snowflake_password")
      .config("snowflakeRole", "your_snowflake_role")
      .config("snowflakeWarehouse", "your_snowflake_warehouse")
      .config("snowflakeDatabase", "your_snowflake_database")
      .config("snowflakeSchema", "your_snowflake_schema")
      .config("spark.executor.memory", "2g")
      .getOrCreateSnowflakeSession()

    // Assuming your table name is "your_table_name"
    val tableName = "your_table_name"

    // Check if any columns end with "ts" or "tms" and are of datatype "VARCHAR"
    val columnsToAlter = session.sql(s"""
      |SELECT COLUMN_NAME
      |FROM INFORMATION_SCHEMA.COLUMNS
      |WHERE TABLE_NAME = '$tableName'
      |  AND (COLUMN_NAME LIKE '%ts' OR COLUMN_NAME LIKE '%tms')
      |  AND DATA_TYPE = 'VARCHAR'
      |""".stripMargin)
      .collect()
      .map(row => row.getString(0))

    // Alter the datatype of columns that end with "ts" or "tms" to "TIMESTAMP"
    if (columnsToAlter.nonEmpty) {
      columnsToAlter.foreach { column =>
        session.sql(s"ALTER TABLE $tableName MODIFY COLUMN $column TIMESTAMP")
      }
      println("Columns were altered.")
    } else {
      println("No columns need to be altered.")
    }
  }
}
