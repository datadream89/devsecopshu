import java.io.File
import com.typesafe.config.{Config, ConfigFactory}
import scala.collection.JavaConverters._

object ConfigParser {
  def main(args: Array[String]): Unit = {
    val folderPath = "configs/" // Update the folder path as needed

    val configFileNames: List[String] = getListOfConfigFiles(folderPath)

    // Parse each config file and extract sections and their values dynamically
    for (configFile <- configFileNames) {
      val config: Config = ConfigFactory.parseFile(new File(configFile))
      processConfig(config)
    }
  }

  def processConfig(config: Config): Unit = {
    val sections = findSections(config)
    sections.foreach { section =>
      val value1 = section.getString("ser")
      val value2 = section.getString("frt")
      // Here, you can define your function and process the section and values as needed
      println(s"Processing section: ${section.origin().filename()} with value1: $value1 and value2: $value2")
    }
  }

  def findSections(config: Config): List[Config] = {
    config.root().keySet().asScala.toList.flatMap { section =>
      val value = config.getAnyRef(section)
      value match {
        case obj: com.typesafe.config.ConfigObject =>
          // Handle sections with object values (recursively)
          findSections(config.getConfig(section))
        case _ =>
          List.empty[Config]
      }
    }
  }

  def getListOfConfigFiles(folderPath: String): List[String] = {
    val folder = new File(folderPath)
    if (folder.exists() && folder.isDirectory) {
      folder.listFiles().filter(_.isFile).map(_.getAbsolutePath).toList
    } else {
      throw new IllegalArgumentException("Invalid folder path")
    }
  }
}
