# Dockerfile

# Use UBI8 as the base image
FROM registry.access.redhat.com/ubi8/ubi:latest

# Set the working directory inside the container
WORKDIR /app

# Install dependencies
RUN yum install -y java-11-openjdk-devel
RUN curl -Ls "https://github.com/sbt/sbt/releases/download/v1.5.5/sbt-1.5.5.tgz" | tar -xz -C /usr/local
RUN curl -Ls "https://downloads.lightbend.com/scala/2.13.6/scala-2.13.6.tgz" | tar -xz -C /usr/local

# Set environment variables for Scala and SBT
ENV SCALA_HOME=/usr/local/scala-2.13.6
ENV PATH=$PATH:$SCALA_HOME/bin

# Copy the project files
COPY snowpark_project /app/snowpark_project

# Set the project directory
WORKDIR /app/snowpark_project

# Build the project
RUN /usr/local/sbt/bin/sbt compile

# Expose any necessary ports
EXPOSE 8080

# Define the entry point command
CMD ["/usr/local/sbt/bin/sbt", "run"]


from openshift import client
import os
# Create an instance of the OpenShift API client
api_client = client.ApiClient()

# Set the OpenShift API URL
api_client.configuration.host = 'https://api.openshift.example.com:6443'

# Set the authentication credentials
username = os.getenv('OPENSHIFT_USERNAME')
password = os.getenv('OPENSHIFT_PASSWORD')

# Create an instance of the CoreV1Api for interacting with the cluster
v1_client = client.CoreV1Api(api_client=api_client)

# Rest of the code...

job_metadata = client.V1ObjectMeta(name="my-job")
job_container = client.V1Container(
    name="my-container",
    image="my-image",
)
job_template = client.V1PodTemplateSpec(
    metadata=job_metadata,
    spec=client.V1PodSpec(restart_policy="Never", containers=[job_container])
)
job_spec = client.V1JobSpec(template=job_template, backoff_limit=0)
job = client.V1Job(api_version="batch/v1", kind="Job", metadata=job_metadata, spec=job_spec)

# Submit the job
v1_client.create_namespaced_job(namespace="my-namespace", body=job)




import java.lang.ProcessBuilder

object SetEnvironmentVariableExample {
  def main(args: Array[String]): Unit = {
    val pb = new ProcessBuilder()
    val env = pb.environment()

    // Set the environment variable
    env.put("MY_ENV_VAR", "variable_value")

    // Optionally, you can also append to an existing environment variable
    // env.put("PATH", env.get("PATH") + ":/path/to/additional/directory")

    // Start a new process with the updated environment
    pb.start()
    
    // Now the environment variable is set for the new process
  }
}


import scalaj.http.{Http, HttpResponse}
import scala.reflect.runtime.{universe => ru}
println("All Environment Variables:")
sys.env.foreach { case (key, value) => println(key + " -> " + value) }

object PackagePathExample {
  def main(args: Array[String]): Unit = {
    val packageName = ru.typeOf[FirstScript].typeSymbol.asClass.fullName
    println(packageName)
  }
}

class HttpClient {
  def sendPostRequest(): Unit = {
    // Define the URL to which you want to send the POST request (HTTPS)
    val url = "https://example.com/api/endpoint"

    // Create a map of form parameters
    val formData = Map(
      "param1" -> "value1",
      "param2" -> "value2"
    )

    // Send the POST request
    val response: HttpResponse[String] = Http(url)
      .postData(formData.map { case (k, v) => s"$k=$v" }.mkString("&"))
      .header("Content-Type", "application/x-www-form-urlencoded")
      .option(HttpOptions.allowUnsafeSSL) // Allow self-signed SSL certificates
      .asString

    // Print the response
    println(response.body)
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    val client = new HttpClient()
    client.sendPostRequest()
  }
}

