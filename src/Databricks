import java.io.File
import com.typesafe.config.{Config, ConfigFactory}
import scala.collection.JavaConverters._

object ConfigParser {
  def main(args: Array[String]): Unit = {
    val folderPath = "configs/" // Update the folder path as needed

    val configFileNames: List[String] = getListOfConfigFiles(folderPath)

    // Parse each config file and extract sections and their values dynamically
    for (configFile <- configFileNames) {
      val config: Config = ConfigFactory.parseFile(new File(configFile))
      processConfig(config, "")
    }
  }

  def processConfig(config: Config, currentPath: String): Unit = {
    val currentSection = if (currentPath.isEmpty) "" else s"$currentPath."

    config.root().keySet().asScala.foreach { section =>
      val fullPath = s"$currentSection$section"
      if (config.getAnyRef(section).isInstanceOf[com.typesafe.config.ConfigObject]) {
        // Handle sections with object values
        val obj = config.getObject(section)
        obj.keySet().asScala.foreach { key =>
          val value = obj.get(key).unwrapped().toString
          processSection(s"$fullPath.$key", value)
        }
      } else {
        // Skip other types
      }
    }
  }

  def processSection(section: String, value: String): Unit = {
    // Here, you can define your function and pass the section and value as arguments
    println(s"Processing section: $section with value: $value")
  }

  def getListOfConfigFiles(folderPath: String): List[String] = {
    val folder = new File(folderPath)
    if (folder.exists() && folder.isDirectory) {
      folder.listFiles().filter(_.isFile).map(_.getAbsolutePath).toList
    } else {
      throw new IllegalArgumentException("Invalid folder path")
    }
  }
}
